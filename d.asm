.MODEL SMALL
.STACK 100H
.DATA
  PROMPT DB "Error$"
  ARGS DB 256 DUP('$')
.CODE
MAIN PROC

  MOV AX, @DATA
  MOV DS, AX ;INTIALIZATION OF DATA SEGMENT

  LEA DI, ARGS ;PARAMETER FOR GET_PARAMS DI(STARTING OFFSET ADDRESS OF PARAMETER STRING) 
  CALL GET_PARAMS 

  LEA SI, ARGS ;PARAMETER FOR CALC_PARAMS SI(STARTING OFFSET ADDRESS OF PARAMETER STRING)
  CALL CALC_PARAMS

  CMP BL, 0 
  JE NO_PARAMS ;JUMP IF NUMBER OF PARAMETERS ARE ZERO 

  CMP BL, 1
  JE ONE_PARAM ;JUMP IF NUMBER OF PARAMETER IS ONE 

  CMP BL, 2 
  JE TWO_PARAMS ;JUMP IF NUMBER OF PARAMETERS ARE TWO 

  ;
  ;ERROR WHEN NUMBER OF PARAMETERS ARE GREATER THAN OR EQUAL TO 3
  ;
  CALL EXIT_DOS

  NO_PARAMS:
    CALL NO_PARAMS_PROCESS
    JMP PREPARE_LOOP

  ONE_PARAM:
    LEA SI, ARGS ;PARAMETER FOR FIND_COLON SI(STRING IN WHICH COLON IS TO FIND)
    CALL FIND_COLON
    CMP BL, 0 
    JE ONE_PARAM_NO_COLON ;JUMP IF NO COLON IS FOUND 

    LEA SI, ARGS ;PARAMETER FOR ONE_PARAM_COLON_PROCESS SI(STRING WHICH HAS INPUT ARGUMENTS)
    CALL ONE_PARAM_COLON_PROCESS
    JMP PREPARE_LOOP

  ONE_PARAM_NO_COLON:
    LEA SI, ARGS ;PARAMETER FOR ONE_PARAM_NO_COLON_PROCESS SI(STRING WHICH HAS INPUT ARGUMENTS)
    CALL ONE_PARAM_NO_COLON_PROCESS
    JMP PREPARE_LOOP

  TWO_PARAMS:
    LEA SI, ARGS ;PARAMETER FOR FIND_COLON SI(STRING IN WHICH COLON IS TO FIND)
    CALL FIND_COLON
    CMP BL, 0
    JE TWO_PARAM_NO_COLON ;JUMP IF NO COLON IS FOUND

    LEA SI, ARGS ;PARAMETER FOR TWO_PARAMS_COLON_PROCESS SI(STRING WHICH HAS INPUT ARGUMENTS)
    CALL TWO_PARAMS_COLON_PROCESS
    JMP PREPARE_LOOP

  TWO_PARAM_NO_COLON:
    LEA SI, ARGS ;PARAMETER FOR TWO_PARAM_NO_COLON_PROCESS SI(STRING WHICH HAS INPUT ARGUMENTS)
    CALL TWO_PARAM_NO_COLON_PROCESS

  PREPARE_LOOP:
    MOV BP, SP 
    MOV DS, [BP + 4]
    MOV AX, [BP + 2]
    AND AX, 0FFF0H
    MOV SI, AX
  OUTTER_LOOP:
    MOV BX, [BP + 4];SEGMENT ADDRESS, PARAMETER FOR PRINT_HEX BX(WHAT TO PRINT)
    MOV CH, 4 ;PARAMETER FOR PRINT_HEX CH(HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    MOV AH, 02H
    MOV DL, ':'
    INT 21H ;DISPLAY COLON BETWEEN SEGMENT AND OFFSET 
    MOV BX, SI ;OFFSET ADDRESS, PARAMETER FOR PRINT_HEX BX(WHAT TO PRINT)
    MOV CH, 4 ;PARAMETER FOR PRINT_HEX CH(HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    MOV AH, 02H
    MOV DL, ' '
    INT 21H ;DISPLAY SPACE 
    INT 21H ;DISPLAY SPACE 
    MOV DI, SI ;PARAMETER FOR PRINT_HEX_SIXTEEN_BYTES DI(STARTING ADDRESS FROM WHERE TO START PRINTING)
    CALL PRINT_HEX_SIXTEEN_BYTES
    MOV AH, 02H
    MOV DL, ' '
    INT 21H ;DISPLAY SPACE
    INT 21H ;DISPLAY SPACE
    MOV DI, SI ;PARAMETER FOR PRINT_ASCII DI(STARTING ADDRESS FROM WHERE TO START PRINTING)
    CALL PRINT_ASCII
    MOV AH, 02H
    MOV DL, 10
    INT 21H ;DISPLAY CARRIGE RETURN
    MOV DL, 13
    INT 21H ;DISPLAY NEW LINE
    MOV SI, DI ;DI IS ALREADY POINTING TO STARTING ADDRESS OF NEXT 16 BYTES
    CMP SI, [BP] ;ENDING OFFSET ADDRESS 
    JLE OUTTER_LOOP ;ITERATE UNTIL STARTING OFFSET ADDRESS IS LESS THAN OR EQUAL TO ENDING OFFSET ADDRESS 
  MOV AH, 4CH
  INT 21H ;EXIT DOS
MAIN ENDP

;
;PARAMETERS DS(MOVE CONTENT TO), ES(MOVE CONTENT FROM), DI(CONTENT MOVE TO)
;RETURN AL(NUMBER OF CHARACTERS IN ARGS)
;
GET_PARAMS PROC
  ;
  ;SAVE CONTENT OF REGISTERS 
  ;
  PUSH BX 
  PUSH SI
  PUSH DI
  PUSH DS 
  PUSH ES 
  MOV AX, DS ;SWAPING
  MOV BX, ES ;DS 
  MOV DS, BX ;WITH 
  MOV ES, AX ;ES
  MOV SI, 0080H ;ARGUMENTS ARE BY DEFAULT AT THIS ADDRESS
  LODSB ;LOADING COUNTER IN AL 
  XOR CX, CX ;CLEARING CX
  MOV CL, AL ;COUNTER OF NUMBER OF ARGUMENTS 
  REP MOVSB ;MOVING DS:SI TO ES:DI 
  ;
  ;RESTORING CONTENT OF REGISTERS 
  ;
  POP ES
  POP DS 
  POP DI
  POP SI 
  POP BX 
  RET 
GET_PARAMS ENDP

;
;PARAMETERS AL(NUMBER OF CHARACTERS IN ARGS), SI(IN WHICH TO FIND SPACES)
;RETURN BL(NUMBER OF PARAMS)
;
CALC_PARAMS PROC
  ;
  ;SAVING CONTENT OF REGISTERS 
  ;
  PUSH AX 
  PUSH CX 
  PUSH SI 
  XOR CX, CX ;LOOP COUNTER 
  MOV CL, AL ;COUNTER = NUMBER OF CHARACTERS IN ARGUMENTS 
  MOV AL, ' ' ;USE FOR COMPARING 
  MOV AH, '$'
  XOR BL, BL ;COUNTER FOR NUMBER OF SAPCES 
  CALC_PARAMS_LOOP:
    CMP [SI], AH
    JE CALC_PARAMS_RETURN
    CMP [SI], AL 
    JNE CALC_PARAMS_NO_SPACE ;JUMP IF CONTENT POINTED BY SI IS NOT SPACE 
    INC BL ;IF SPACE IS ENCOUNTER THAN INCREMENT BL 
    CALC_PARAMS_NO_SPACE:
    INC SI ;SI POINT TO NEXT ADDRESS 
    LOOP CALC_PARAMS_LOOP
  CALC_PARAMS_RETURN:
  ;
  ;RESTORING CONTENT OF REGISTERS 
  ;
  POP SI 
  POP CX 
  POP AX
  RET  
CALC_PARAMS ENDP

;
;STORE SEGMENT = 073FH, STARTING OFFSET = 0100H AND ENDING OFFSET = 017FH IN STACK 
;
NO_PARAMS_PROCESS PROC
  POP DX ;SAVING RETURN ADDRESS 
  MOV AX, 073FH ;DEFAULT SEGMENT ADDRESS 
  PUSH AX
  MOV AX, 0100H ;DEFAULT STARTING OFFSET ADDRESS 
  PUSH AX
  MOV AX, 017FH ;DEFAULT ENDING OFFSET ADDRESS 
  PUSH AX
  PUSH DX ;PUSHING RETURN ADDRESS SO RET CAN EXECUTE 
  RET
NO_PARAMS_PROCESS ENDP

;
;STORE SEGMENT = 073FH, STARTING OFFSET = ONE_PARAM AND ENDING OFFSET = ONE_PARAM + 7FH IN STACK 
;
ONE_PARAM_NO_COLON_PROCESS PROC 
  POP DX ;SAVING RETURN ADDRESS 
  INC SI ;INCREMENTING BECAUSE FIRST CHARACTER IN SI IS SPACE 
  MOV AL, ' ' ;PARAMETER FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4
  JG ONE_PARAM_NO_COLON_PROCESS_WRONG ;NUMBER OF CHARACTERS ARE GREATER THAN 4 IS WRONG 
  CALL HEX_INPUT
  MOV AX, 073FH ;DEFAULT SEGMENT ADDRESS 
  PUSH AX 
  PUSH BX ;USER INPUT FOR STARTING OFFSET ADDRESS 
  ADD BX, 007FH ;ENDING OFFSET ADDRESS 
  PUSH BX 
  PUSH DX ;PUSHING RETURN ADDRESS BACK FOR RET 
  RET 
  ONE_PARAM_NO_COLON_PROCESS_WRONG:
    CALL EXIT_DOS
ONE_PARAM_NO_COLON_PROCESS ENDP 

;
;PARAMETER SI(STARTING ADDRESS OF INPUT ARGUMENT STRING)
;
ONE_PARAM_COLON_PROCESS PROC
  POP DX ;SAVING RETURN ADDRESS 
  INC SI ;INCRMENTING SI BEACUSE FIRST CHARACTER IS SPACE 
  MOV AL, ':' ;PARAMETER FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4 
  JG ONE_PARAM_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT 
  PUSH BX ;STORE USER INPUT OF SEGMENT ADDRESS 
  XOR CL, CL ;CLEARING CL 
  XCHG CL, CH  
  ADD SI, CX ;NUMBER OF CHARACTERS ALREADY READ
  INC SI ;INCREMENTING BECAUSE IT IS COLON 
  MOV AL, ' ' ;PARAMETER FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4
  JG ONE_PARAM_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT 
  PUSH BX ;STORE USER INPUT OF STARTING OFFSET ADDRESS 
  ADD BX, 007FH ;ENDING OFFSET ADDRESS 
  PUSH BX 
  PUSH DX ;PUSHING RETURN ADDRESS FOR RET 
  RET 
  ONE_PARAM_COLON_PROCESS_WRONG:
    CALL EXIT_DOS
ONE_PARAM_COLON_PROCESS ENDP

;
;PARAMETER SI(STARTING ADDRESS OF INPUT ARGUMENT STRING)
;
TWO_PARAM_NO_COLON_PROCESS PROC
  POP DX ;SAVING RETURN ADDRESS 
  MOV BX, 073FH ;DEFAULT SEGMENT ADDRESS 
  PUSH BX 
  INC SI ;INCREMENTING BECAUSE FIRST CHARACTER IS SPACE 
  MOV AL, ' ' ;PARAMETERS FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4 
  JG TWO_PARAM_NO_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT
  PUSH BX ;STORE STARTING OFFSET ADDRESS 
  XOR CL, CL ;CLEARING CL
  XCHG CL, CH 
  ADD SI, CX ;NUMBER OF CHARACTERS ALREADY READ
  INC SI ;INCREMENTING BECAUSE IT IS SPACE 
  MOV AL, ' ' ;PARAMETER FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4
  JG TWO_PARAM_NO_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT
  PUSH BX ;ENDING OFFSET ADDRESS
  PUSH DX ;PUSHING RETURN ADDRESS FOR RET 
  RET 
  TWO_PARAM_NO_COLON_PROCESS_WRONG:
    CALL EXIT_DOS
TWO_PARAM_NO_COLON_PROCESS ENDP 

;
;PARAMETER SI(STARTING ADDRESS OF INPUT ARGUMENT STRING)
;
TWO_PARAMS_COLON_PROCESS PROC 
  POP DX ;SAVING RETURN ADDRESS 
  INC SI ;INCREMENTING BECAUSE FIRST CHARACTER IS SPACE 
  MOV AL, ':' ;PARAMETERS FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4
  JG TWO_PARAMS_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT
  PUSH BX ;STORE SEGMENT ADDRESS 
  XOR CL, CL ;CLEARING CL
  XCHG CL, CH 
  ADD SI, CX ;NUMBER OF CHARACTERS ALREADY READ
  INC SI ;INCREMENTING BECAUSE IT IS COLON 
  MOV AL, ' ' ;PARAMETERS FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4 
  JG TWO_PARAMS_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT
  PUSH BX ;STORE STARTING OFFSET ADDRESS 
  XOR CL, CL ;CLEARING CL
  XCHG CL, CH 
  ADD SI, CX ;NUMBER OF CHARACTERS ALREADY READ
  INC SI ;INCREMENTING BECAUSE IT IS SPACE 
  MOV AL, ' ' ;PARAMETERS FOR READ_STRING_COUNT AL(READ UNTIL)
  CALL READ_STRING_COUNT
  CMP CH, 4 
  JG TWO_PARAMS_COLON_PROCESS_WRONG ;JUMP IF NUMBER OF CHARACTERS BEFORE COLON IS FREATER THAN 4
  CALL HEX_INPUT
  PUSH BX ;STORE ENDING OFFSET ADDRESS 
  PUSH DX ;PUSHING RETURN ADDRESS FOR RET 
  RET 
  TWO_PARAMS_COLON_PROCESS_WRONG:
    CALL EXIT_DOS
TWO_PARAMS_COLON_PROCESS ENDP 

;
;PARAMETERS SI(STARTING OFFSET ADDRESS OF STRING), AL(FIND IN STRING)
;RETURN CH(NUMBER OF CHARACTERS FROM STRING OFFSET ADDRESS TO CHARACTER IN AL)
;
READ_STRING_COUNT PROC
  ;
  ;SAVING CONTENT OF REGISTERS 
  ;
  PUSH AX
  PUSH SI 
  MOV AH, '$' ;READ UNTIL $
  XOR CH, CH ;COUNTER 
  READ_STRING_COUNT_LOOP:
    CMP [SI], AL 
    JE READ_STRING_COUNT_END ;JUMP IF CHARACTER ENCOUNTER
    CMP [SI], AH
    JE READ_STRING_COUNT_END ;JUMP IF $ ENCOUNTER 
    INC CH ;INCREMENTING COUNTER 
    INC SI ;INCREMENTING OFFSET ADDRESS 
    JMP READ_STRING_COUNT_LOOP
  READ_STRING_COUNT_END:
  ;
  ;RESTORE CONTENT OF REGISTERS 
  ;
  POP SI 
  POP AX
  RET 
READ_STRING_COUNT ENDP 

;
;PARAMETERS AL(NUMBER OF CHARACTERS), SI(IN WHICH TO FIND COLON)
;RETURN BL(COLON IS PRESENT OR NOT) 
;
FIND_COLON PROC
  PUSH AX
  PUSH CX
  PUSH SI 
  XOR CX, CX
  MOV CL, AL
  MOV AL, ':'
  LEA SI, ARGS
  FIND_COLON_LOOP:
    CMP [SI], AL 
    JE FIND_COLON_YES
    INC SI 
    LOOP FIND_COLON_LOOP
  MOV BL, 0
  JMP FIND_COLON_RETUEN
  FIND_COLON_YES:
    MOV BL, 1
  FIND_COLON_RETUEN:
  POP SI 
  POP CX 
  POP AX 
  RET 
FIND_COLON ENDP

EXIT_DOS PROC 
  MOV AH, 09H
  LEA DX, PROMPT
  INT 21H
  MOV AH, 4CH
  INT 21H 
EXIT_DOS ENDP 

;
;PARAMETERS ARE CH(NUMBER OF CHARACTERS TO INPUT), RETURN BX(4-HEX DIGITS)
;
HEX_INPUT PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  XOR BX, BX ;HOLD INPUT FROM USER
  MOV CL, 4 ;USE IN SHIFTING (NUMBER OF BITS TO SHIFT)
  HEX_INPUT_LOOP:
    MOV AL, [SI]
    CMP AL, '0'
    JL HEX_INPUT_WRONG ;JUMP IF LESS THAN '0'
    CMP AL, '9'
    JLE HEX_INPUT_DIGIT ;JUMP IF LESS THAN '9'
    CMP AL, 'A'
    JL HEX_INPUT_WRONG ; JUMP IF LESS THAN 'A'
    CMP AL, 'F'
    JLE HEX_INPUT_UP_CHARACTER ;JUMP IF LESS THAN 'F'
    CMP AL, 'a'
    JL HEX_INPUT_WRONG ;JUMP IF LESS THAN 'a'
    CMP AL, 'f'
    JLE HEX_INPUT_LO_CHARACTER ;JUMP IF LESS THAN 'f'
    HEX_INPUT_WRONG:
      CALL EXIT_DOS
    HEX_INPUT_DIGIT:
      SUB AL, 30H ;CONVERTING TO DIGIT 
      JMP HEX_INPUT_STORE
    HEX_INPUT_UP_CHARACTER:
      SUB AL, 37H ;CONVERTING TO HEX CHARACTER
      JMP HEX_INPUT_STORE
    HEX_INPUT_LO_CHARACTER:
      SUB AL, 57H ;CONVERTING TO HEX CHARACTER
    HEX_INPUT_STORE:
      SHL BX, CL ;SHIFTING LOWER NIBBLE TO UPPER NIBBLE 
      OR BL, AL ;MAKING USER INPUT AS RIGHT MOST DIGIT IN BX 
    INC SI 
    DEC CH ;DECEMENTING COUNTER
    JNZ HEX_INPUT_LOOP
    ;
    ;RESTORING CONTENT OF REGISTERS
    ;
    POP BP
    POP DI
    POP SI
    POP DX
    POP CX
    POP AX
    RET 
HEX_INPUT ENDP

;
;PARAMETERS ARE BX(HOLD WHICH IS TO BE PRINTED), CH(HOW MANY TO PRINT)
;
PRINT_HEX PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  MOV CL, 4 ;USE IN SHIFTING (NUMBER OF BITS TO SHIFT)
  PRINT_HEX_OUTPUT:
    MOV DL, BH ;ALWAYS DISPLAY UPPER BYTE
    SHR DL, CL ;ALWAYS DISPLAY LOWER NIBBLE OF UPPER BYTER
    CMP DL, 9 
    JLE PRINT_HEX_DIGIT ;JUMP IF IT'S A DIGIT 
    ADD DL, 37H ;CONVERTING TO CHARCATER 
    JMP PRINT_HEX_DISPLAY
    PRINT_HEX_DIGIT:
      ADD DL, 30H ;CONVERTING TO DIGIT 
    PRINT_HEX_DISPLAY:
      MOV AH, 02H ;DISPLAY CHARACTER 
      INT 21H
    ROL BX, CL ;MOVING LOWER NIBBLE TO UPPER NIBBLE
    DEC CH ;DECREMENTING COUNTER
    JNZ PRINT_HEX_OUTPUT ;JUMP IF COUNTER IT NOT ZERO
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP DI
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_HEX ENDP

;
;PARAMETERS ARE DI(HOLD STARTING OFFSET ADDRESS OF 8 BYTES TO BE PRINTED)
;
PRINT_HEX_SIXTEEN_BYTES PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH BP
  MOV BP, SP 
  MOV CX, 16 ;NUMBER OF BYTES IN EACH LINE 
  PRINT_HEX_SIXTEEN_BYTES_OUTPUT:
    PUSH CX ;STORING COUNTER AS CH IS USED FOR PRINT_HEX FUNCTION
    CMP DI, [BP + 14 + 2] ;STARTING OFFSET ADDRESS
    JL PRINT_HEX_SIXTEEN_BYTES_SPACES ;JUMP IF CURRENT ADDRESS IS LESS THAN STARTING OFFSET ADDRESS
    CMP DI, [BP + 14 + 0] ;ENDING OFFSET ADDRESS
    JG PRINT_HEX_SIXTEEN_BYTES_SPACES ;JUMP IF CURRENT ADDRESS IS GREATER THAN ENDING OFFSET ADDRESS
    MOV BH, [DI] ;PARAMETER FOR PRINT_HEX FUNCTION (STARTING ADDRESS OF WHAT TO PRINT)
    MOV CH, 2 ;PARAMETER FOR PRINT_HEX FUNCTION (HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    POP CX ;RESTORING COUNTER
    CMP CX, 9 ;PRINT HYPEN AFTER PRINTING 7H BYTE 
    JE PRINT_HEX_SIXTEEN_BYTES_HYPEN ;JUMP IF COUNTER IS 9
    MOV DL, ' ' 
    MOV AH, 02H 
    INT 21H ;DISPLAY SPACE
    JMP PRINT_HEX_SIXTEEN_BYTES_NEXT
    PRINT_HEX_SIXTEEN_BYTES_HYPEN:
    MOV AH, 02H
    MOV DL, '-'
    INT 21H ;DISPLAY HYPEN 
    JMP PRINT_HEX_SIXTEEN_BYTES_NEXT
    PRINT_HEX_SIXTEEN_BYTES_SPACES:
      POP CX ; RESTORING COUNTER
      MOV AH, 02H
      MOV DL, ' '
      INT 21H ;DISPLAY SPACE 
      INT 21H ;DISPLAY SPACE 
      INT 21H ;DISPLAY SPACE 
    PRINT_HEX_SIXTEEN_BYTES_NEXT:
    INC DI ;INCREMENTING TO PRINT NEXT BYTE 
    LOOP PRINT_HEX_SIXTEEN_BYTES_OUTPUT
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_HEX_SIXTEEN_BYTES ENDP

;
;PARAMETERS ARE DI(HOLD STARTING OFFSET ADDRESS OF 16 BYTES TO BE PRINTED)
;
PRINT_ASCII PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH BP
  MOV BP, SP 
  MOV CX, 16 ;NUMBER OF BYTES IN EACH LINE
  PRINT_ASCII_OUTPUT:
    CMP DI, [BP + 12 + 4] ;STARTING OFFSET ADDRESS
    JL PRINT_ASCII_SPACES ;JUMP IF CURRENT ADDRESS IS LESS THAN STARTING OFFSET ADDRESS
    CMP DI, [BP + 12 + 2] ;ENDING OFFSET ADDRESS
    JG PRINT_ASCII_SPACES ;JUMP IF CURRENT ADDRESS IS GREATER THAN ENDING OFFSET ADDRESS
    MOV DL, [DI] ;MOVING CONTENT OF DI TO PRINT 
    CMP DL, 20H
    JL PRINT_ASCII_DOT ;JUMP IF LESS THEN 20H
    CMP DL, 7EH
    JG PRINT_ASCII_DOT ;JUMP IF GREATER THEN 73H 
    JMP PRINT_ASCII_DISPLAY
    PRINT_ASCII_DOT:
      MOV DL, '.' ;DISPLAY (.)
      PRINT_ASCII_DISPLAY:
        MOV AH, 02H
        INT 21H ;DISPLAY CHARCATER
      JMP PRINT_ASCII_REMAIN
    PRINT_ASCII_SPACES:
      MOV AH, 02H
      MOV DL, ' '
      INT 21H ;DISPLAY SPACES 
    PRINT_ASCII_REMAIN:
    INC DI ;INCREMENTINFG DI SO IT CAN POINT TO NEXT BYTE TO PRINT 
    LOOP PRINT_ASCII_OUTPUT
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_ASCII ENDP

END MAIN
